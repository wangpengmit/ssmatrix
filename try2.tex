\documentclass{article}

\usepackage{amsmath}

\begin{coq_eval}
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive. 

Require Import ssreflect ssrfun ssrbool eqtype ssrnat div seq choice fintype.
Require Import finfun bigop prime binomial.

Require Import matrix.
Require Import ssralg.
Import GRing.Theory.
Open Local Scope ring_scope.

Require Import bimodule.
Require Import derivation.
Require Import mxutil.
Import Notations.
Require Import mxmodule.
Import Notations.
Require Import mxdiff.
Import Notations.
Require Import eccv_paper_appendix.
Import Notations.

Section Section3.

(* Constants *)
Variable C : ringType.
(* Variables and matrix elements *)
Variable E : unitComAlgType C.
(* Co-domain of differentiation operator *)
Variable D : comBimodType E.
Variable der : {linearDer E -> D}.
Notation "\d" := (LinearDer.apply der).
Notation "\\d" := (map_mx \d).

(* All dimensions are non-zero. All matrices are non-empty. *)
Variable m' n' r' : nat.
Local Notation m := m'.+1.
Local Notation n := n'.+1.
Local Notation r := r'.+1.

(* W : weight matrix 
   M : target matrix 
   They are constant matrices, and are lifted to participate in matrix operations. *)
Variable cW cM : 'M[C]_(m, n).
Notation W := (lift cW).
Notation M := (lift cM).
Variable U : 'M[E]_(m, r).
Notation "~W" := (diag_mx (vec W)^T).
Notation "\m" := (vec M).
Notation "~U" := (I *o U).
(* Regularization rate *)
Variable v : C.
Notation eps1 := (~W *m \m - ~W *m ~U *m (~W *m ~U)^-v *m ~W *m \m).
Notation H := (I - ~W *m ~U *m (~W *m ~U)^-v).
Notation "V*" := ((cvec_mx ((~W *m ~U)^-v *m ~W *m \m))^T).
Notation R := (W .* (M - U *m V*^T)).
Notation "~V*" := (V* *o I).
(* The permutation matrix for transposing *)
Notation T := (trT _ _ _).
Notation "v*" := ((~W *m ~U)^-v *m ~W *m \m).
Notation J2 := (0 - (~W *m ~U)^-v *m ~W *m (V* *o I) + ((~W *m ~U)^T *m (~W *m ~U) + v *ml: I)^^-1 *m ((W .* R)^T *o I) *m T).
Notation J1 := (-(H *m ~W *m ~V* + ((~W *m ~U)^-v)^T *m ((W .* R)^T *o I) *m T)).
Notation "~WR" := ((W .* R) *o I).
Notation "A ^+" := (A^-0) (at level 3, format "A ^+").

Hypothesis h_invertible : invertible (mupinv_core v (~W *m ~U)).
\end{coq_eval}

\begin{document}

Before.

\begin{coq_example}
(*!- \coqadd{\*:}{ } *)
(*!- \coqadd{:\*}{ } *)
(*!- \coqadd{\*m:}{ } *)
(*!- \coqadd{\*ml:}{ } *)
(*!- \coqadd{\*m\b}{ } *)
(*!- \coqadd{\*ml\b}{ } *)
(*!- \coqadd{\*mr\b}{ } *)
(*!- \coqadd{\.\*}{\odot} *)
(*!- \coqadd{\bvec\b}{\mathrm{vec}} *)
(*!- \coqadd{\bsym\b}{\mathrm{sym}} *)
(*!- \coqadd{\\\\d}{\partial} *)
(*!- \coqadd{\*o\b}{\otimes} *)
(*!- \coqadd{\*ol\b}{\otimes} *)
(*!- \coqadd{\*or\b}{\otimes} *)
(*!- \coqadd{\^T\b}{^\top} *)
(*!- \coqadd{\^\+}{^\dagger} *)
(*!- \coqadd{\^\^\s*-1}{^{-1}} *)
(*!- \coqadd{\^-\s*(\w+)}{^{-\1}} *)
(*!- \coqadd{\\m\b}{\mathbf{m}} *)
(*!- \coqadd{~WR\b}{\widetilde{WR}} *)
(*!- \coqadd{~W\b}{\widetilde{W}} *)
(*!- \coqadd{~U\b}{\widetilde{U}} *)
(*!- \coqadd{\bV\*}{{V^*}} *)
(*!- \coqadd{~V\*}{{\widetilde{V}^*}} *)
(*!- \coqadd{\bv\*}{{v^*}} *)
(*!- \coqadd{\bv\b}{\nu} *)
(*!- \coqadd{\beps1\b}{\epsilon_1} *)

(* Corresponds to Equation (10)~(13) *)
(*! \begin{align} *)
Lemma vec_dot V : vec (W .* (M - U *m V^T)) = ~W *m \m - ~W *m ~U *m vec V^T.
Proof.
  (*! \coqvar{from} &=  *)
  set goal := RHS.
  rewrite vec_elemprod.
  (*! \coqvar{lhs} \\ *)
  rewrite !raddfB /=.
  (*! &= \coqvar{lhs} \\ *)
  by rewrite vec_kron !mulmxA.
  (*! &= \coqvar{to} \label{eq:\coqvar{name}} *)
Qed.
(*! \end{align} *)
\end{coq_example}

Middle.

\begin{coq_example}
Lemma dmmr {p} (A : 'M[E]_(p, _)) : \\d (A *m \m) = \\d A *mr \m.
Proof.
  by rewrite -!lift_vec !dmcr.
Qed.

Lemma dmWr {p} (A : 'M[E]_(p, _)) : \\d (A *m ~W) = \\d A *mr ~W.
Proof.
  by rewrite -!lift_vec map_trmx -map_diag_mx !dmcr.
Qed.

Lemma dmWl {p} (A : 'M[E]_(_, p)) : \\d (~W *m A) = ~W *ml \\d A.
Proof.
  by rewrite -!lift_vec map_trmx -map_diag_mx !dmcl.
Qed.

(* Corresponds to Equation (20)~(26) *)
(*! \begin{align} *)
Lemma d_eps1_part1 : \\d eps1 = 0 - H *m ~W *ml (I *ol \\d U) *mr ((~W *m ~U)^-v *m ~W *m \m) - ((~W *m ~U)^-v)^T *ml (I *ol (\\d U)^T) *mr (~W^T *m H *m ~W *m \m).
Proof.
  set goal := RHS.
  rewrite raddfB /= -(mul1mx (~W *m \m)) !mulmxA !dmmr !dmWr dmI !rmul0mx.
  (*! \coqvar{from} &= \coqvar{lhs} \\ *)
  rewrite (dm_AmupinvA _ h_invertible). (* (22) *)
  (*! &= \coqvar{lhs} \\ *)
  rewrite dmWl (dm_lkron1mx _ _ U) !lmulmxA /=. (* (25) *)
  (*! &= \coqvar{lhs} \\ *)
  by rewrite /sym [in _^T + _]addrC !trmx_rmulmx !trmx_lmulmx !trmx_mul /= (trmx_lkron I (\\d U)) raddfB /= AmupinvA_sym !trmx1 !rmulmxDl opprD addrA !lrmulmxA !rmulmxA -!rmulmxA !mulmxA.
  (*! &= \coqvar{to} \label{eq:\coqvar{name}} *)
Qed.
(*! \end{align} *)

Lemma to_Vstar : (~W *m ~U)^-v *m ~W *m \m = vec V*^T.
Proof.
  by rewrite (trmxK V*) cvec_mxK.
Qed.

(* Corresponds to Equation (28)~(31) *)
(*! \begin{align} *)
Lemma to_vec_dot : ~W^T *m H *m ~W *m \m = vec (W .* R).
Proof.
  set goal := RHS.
  rewrite mulmxBr !mulmxBl !mulmxA mulmx1.
  (*! \coqvar{from} &= \coqvar{lhs} \\ *)
  rewrite -(mulmxA _ _ ~W) -(mulmxA _ (_ *m _) \m) to_Vstar.
  (*! &= \coqvar{lhs} \\ *)
  rewrite -!mulmxA -mulmxBr !mulmxA -vec_dot.
  (*! &= \coqvar{lhs} \\ *)
  by rewrite tr_diag_mx -vec_elemprod.
  (*! &= \coqvar{to} \label{eq:\coqvar{name}} *)
Qed.
(*! \end{align} *)

(* Corresponds to Equation (32)~(34) *)
(*! \begin{align} *)
Lemma d_eps1 : \\d eps1 = -(H *m ~W *m ~V* + ((~W *m ~U)^-v)^T *m ((W .* R)^T *o I) *m T) *ml \\d (vec U).
Proof.
  set goal := RHS.
  rewrite d_eps1_part1 to_vec_dot {1}to_Vstar.
  (*! \coqvar{from} &= \coqvar{lhs} \\ *)
  by rewrite -!lrmulmxA !lkron_shift (trmxK V*) !lmulmxA -trTPcrmul !lmulmxA sub0r -opprD -!(lmulmxDl _ _ (vec (\\d U))) -(map_vec _ U) -(lmulNmx _ (\\d _)).
  (*! &= \coqvar{to} \label{eq:\coqvar{name}} *)
Qed.
(*! \end{align} *)

Lemma dmWTr {p} (A : 'M[E]_(p, _)) : \\d (A *m ~W^T) = \\d A *mr ~W^T.
Proof.
  by rewrite -!lift_vec map_trmx -map_diag_mx  map_trmx !dmcr.
Qed.

(* Corresponds to Equation (36)~(40) *)
(*! \begin{align} *)
Lemma d_vstar_part1 : \\d v* = 0 - (~W *m ~U)^-v *m ~W *ml (I *ol \\d U) *mr ((~W *m ~U)^-v *m ~W *m \m) + ((~W *m ~U)^T *m (~W *m ~U) + v *ml: I)^^-1 *ml (I *ol \\d U)^T *mr (~W^T *m (I - (~W *m ~U) *m (~W *m ~U)^-v) *m ~W *m \m).
Proof.
  set goal := RHS.
  rewrite dmmr dmWr.
  (*! \coqvar{from} &= \coqvar{lhs} \\ *)
  rewrite (dm_mupinv _ h_invertible) 2!rmulmxDl 2!rmulmxBl !rmul0mx.
  (*! &= \coqvar{lhs} \\ *)
  by rewrite (map_trmx \d) trmx_mul dmWl dmWTr -(map_trmx \d) !(dm_lkron1mx _ _ U) /= !lrmulmxA !lmulmxA -!rmulmxA !mulmxA -trmx_mul -[in _^T *m _ *m _]mulmxA.
  (*! &= \coqvar{to} \label{eq:\coqvar{name}} *)
Qed.
(*! \end{align} *)

(* Corresponds to Equation (40')~(48) *)
(*! \begin{align} *)
Lemma d_vstar_part2 : \\d v* = (0 - (~W *m ~U)^-v *m ~W *m (V* *o I) + ((~W *m ~U)^T *m (~W *m ~U) + v *ml: I)^^-1 *m ((W .* R)^T *o I) *m T) *ml vec (\\d U).
Proof.
  set goal := RHS.
  rewrite d_vstar_part1 trmx_lkron trmx1.
  (*! \coqvar{from} &= \coqvar{lhs} \\ *)
  rewrite to_Vstar to_vec_dot.
  (*! &= \coqvar{lhs} \\ *)
  rewrite -!lrmulmxA !lkron_shift (trmxK V*) !lmulmxA.
  (*! &= \coqvar{lhs} \\ *)
  by rewrite -trTPcrmul !lmulmxA sub0r addrC -!(lmulmxBl _ _ (vec (\\d U))) addrC -sub0r.
  (*! &= \coqvar{to} \label{eq:\coqvar{name}} *)
Qed.
(*! \end{align} *)

(* Corresponds to Equation (49)~(52) *)
(*! \begin{align} *)
Lemma J2_simpl : J2 = 0 - ((~W *m ~U)^T *m (~W *m ~U) + v *ml: I)^^-1 *m ((I *o U^T)*m ~W^T *m ~W *m (V* *o I) - ((W .* R)^T *o I) *m T).
Proof.
  set goal := RHS.
  rewrite -{1}fold_mupinv sub0r addrC -opprB -!(mulmxA _^^-1) -mulmxBr.
  (*! \coqvar{from} &= \coqvar{lhs} \\ *)
  by rewrite [in _ - _]trmx_mul [in ~U^T]trmx_kron trmx1 -sub0r.
  (*! &= \coqvar{to} \label{eq:\coqvar{name}} *)
Qed.
(*! \end{align} *)

Hypothesis v_0 : v = 0.

Lemma mulpinvmx m n (A : 'M[E]_(m,n)) : invertible (mupinv_core 0 A) -> A^+ *m A = I.
Proof.
  rewrite unlock /mupinv /mupinv_core lscale0mx addr0.
  by move => h; rewrite -(mulmxA _^^-1) mulVmx.
Qed.

Lemma pinv_pinv m n (A : 'M[E]_(m,n)) : invertible (mupinv_core 0 A) -> A^+ *m A^+^T = (A^T *m A)^^-1.
Proof.
  move => h.
  by rewrite [in _^+^T]unlock /mupinv /mupinv_core /= lscale0mx addr0 !trmx_mul !trmxK !mulmxA (mulpinvmx h) mul1mx trmx_inv !trmx_mul !trmxK.
Qed.

Lemma pinvWU_WU : (~W *m ~U)^+ *m ~W *m ~U = I.
Proof.
  move: h_invertible; rewrite v_0 => h.
  by rewrite -mulmxA (mulpinvmx h).
Qed.

Lemma WU_H_0 : (~W *m ~U)^+ *m H = 0.
Proof.
  by rewrite mulmxBr mulmx1 !mulmxA pinvWU_WU mul1mx v_0 addrN.
Qed.

Lemma trmx_kronmx1 (R : comRingType) m1 n1 m2 (A : 'M[R]_(m1,n1)) : (A *o I)^T = A^T *o (I : 'M_m2).
Proof. by rewrite trmx_kron trmx1. Qed.

Lemma J1_simpl : J1 = -(H *m ~W *m ~V* + ((~W *m ~U)^+)^T *m ~WR^T *m T).
Proof.
  set goal := RHS.
  by rewrite [in (_^-v)^T]v_0 -[in (W .* R)^T *o _]trmx_kronmx1.
Qed.

Lemma H_H : H^T *m H = H.
Proof.
  by rewrite !raddfB /= AmupinvA_sym !trmx1 mulmx1 mulmxBl mul1mx -!mulmxA ![in _^-v *m _]mulmxA v_0 pinvWU_WU !mulmxA !mulmx1 addrN subr0.
Qed.

Lemma pinvWU_pinvWU : (~W *m ~U)^+ *m (~W *m ~U)^+^T = ((~W *m ~U)^T *m (~W *m ~U))^^-1.
Proof.
  move: h_invertible; rewrite v_0 => h.
  by rewrite (pinv_pinv h).
Qed.

(* This notation works better with Latex *)
Notation "{( A )^+}" := (A^-0) (at level 3).

(* Corresponds to Equation (54)~(56) *)
(*! \begin{align} *)
Lemma J1_J1 : J1^T *m J1 = ~V*^T *m ~W^T *m H *m ~W *m ~V* + T^T *m ~WR *m ((~W *m ~U)^T *m (~W *m ~U))^^-1 *m ~WR^T *m T.
Proof.
  set goal := RHS.
  rewrite J1_simpl [in _^T] raddfN /= mulNmx mulmxN opprK [in _^T] raddfD /= !trmx_mul (trmxK ~WR) (trmxK _^+) [_ *m (_ + _)]mulmxDl mulmxDr mulmxDr !mulmxA !addrA.
  (*! \coqvar{from} &= \coqvar{lhs} \\ *)
  rewrite -!(mulmxA _ _ H) WU_H_0 -!(mulmxA _ _ _^+^T) -[H^T *m _^+^T]trmx_mul WU_H_0 !mulmxA trmx0 !mulmx0 !mul0mx !addr0.
  (*! &= \coqvar{lhs} \\ *)
  by rewrite -!(mulmxA _ _ H) H_H -(mulmxA _ _ _^+^T) pinvWU_pinvWU.
  (*! &= \coqvar{to} \label{eq:\coqvar{name}} *)
Qed.
(*! \end{align} *)
End Section3.
\end{coq_example}

After.

\end{document}
